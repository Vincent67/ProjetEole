<html xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:MSHelp="http://msdn.microsoft.com/mshelp" xmlns:mshelp="http://msdn.microsoft.com/mshelp" xmlns:ddue="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:msxsl="urn:schemas-microsoft-com:xslt"><head><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8" /><META NAME="save" CONTENT="history" /><title>Utilisation des types de données de base</title><meta name="Language" content="fr-fr" /><meta name="System.Keywords" content="types de données de base" /><meta name="Microsoft.Help.Id" content="d7044936-5b8c-4def-858c-28a11ef70a97" /><meta name="Description" content="Le Pilote JDBC Microsoft pour SQL Server utilise les types de données de base JDBC pour convertir les types de données SQL Server en un format compréhensible par le langage de programmation Java et inversement. Le pilote JDBC prend en charge l'API JDBC 4." /><meta name="Microsoft.Help.ContentType" content="Concepts" /><link rel="stylesheet" type="text/css" href="../local/Classic.css" /><script type="text/javascript" src="../scripts/EventUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/SplitScreen.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/Dropdown.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_manifold.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_feedBack.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CheckboxMenu.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CommonUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../local/script_main.js">&amp;nbsp;</script></head><body><div id="header"><table id="bottomTable" cellpadding="0" cellspacing="0"><tr><td align="left"><span id="headerBold">Utilisation des types de données de base</span></td></tr></table><table id="gradientTable"><tr><td class="nsrBottom" background="../icons/gradient.gif" /></tr></table></div><div id="mainSection"><div id="mainBody"><div class="introduction"><p>Le Pilote JDBC Microsoft pour SQL Server utilise les types de données de base JDBC pour convertir les types de données SQL Server en un format compréhensible par le langage de programmation Java et inversement. Le pilote JDBC prend en charge l'API JDBC 4.0, qui inclut le type de données <span sdata="langKeyword" value="SQLXML"><span class="keyword">SQLXML</span></span> et les types de données nationaux (Unicode), par exemple <span sdata="langKeyword" value="NCHAR"><span class="keyword">NCHAR</span></span>, <span sdata="langKeyword" value="NVARCHAR"><span class="keyword">NVARCHAR</span></span>, <span sdata="langKeyword" value="LONGNVARCHAR"><span class="keyword">LONGNVARCHAR</span></span> et <span sdata="langKeyword" value="NCLOB"><span class="keyword">NCLOB</span></span>.</p></div><h1 class="heading">Mappages de types de données</h1><div id="sectionSection0" class="section" name="collapseableSection" style=""><p>Le tableau suivant répertorie les mappages par défaut entre les types de données de base SQL Server, JDBC et du langage de programmation Java :</p><div class="tableSection"><table width="50%" cellspacing="2" cellpadding="5" frame="lhs"><tr><th><p>Types SQL Server</p></th><th><p>Types JDBC (java.sql.Types)</p></th><th><p>Types langage Java</p></th></tr><tr><td><p>bigint</p></td><td><p>BIGINT</p></td><td><p>long</p></td></tr><tr><td><p>binary</p></td><td><p>BINARY</p></td><td><p>byte[]</p></td></tr><tr><td><p>bit</p></td><td><p>BIT</p></td><td><p>boolean</p></td></tr><tr><td><p>char</p></td><td><p>CHAR</p></td><td><p>String </p></td></tr><tr><td><p>date</p></td><td><p>DATE</p></td><td><p>java.sql.Date</p></td></tr><tr><td><p>datetime</p></td><td><p>TIMESTAMP</p></td><td><p>java.sql.Timestamp</p></td></tr><tr><td><p>datetime2</p></td><td><p>TIMESTAMP</p></td><td><p>java.sql.Timestamp</p></td></tr><tr><td><p>datetimeoffset (2)</p></td><td><p>microsoft.sql.Types.DATETIMEOFFSET</p></td><td><p>microsoft.sql.DateTimeOffset</p></td></tr><tr><td><p>decimal</p></td><td><p>DECIMAL</p></td><td><p>java.math.BigDecimal</p></td></tr><tr><td><p>float</p></td><td><p>DOUBLE</p></td><td><p>double</p></td></tr><tr><td><p>image</p></td><td><p>LONGVARBINARY</p></td><td><p>byte[]</p></td></tr><tr><td><p>int</p></td><td><p>INTEGER</p></td><td><p>int</p></td></tr><tr><td><p>money</p></td><td><p>DECIMAL</p></td><td><p>java.math.BigDecimal</p></td></tr><tr><td><p>nchar</p></td><td><p>CHAR</p><p>NCHAR (Java SE 6.0)</p></td><td><p>String </p></td></tr><tr><td><p>ntext</p></td><td><p>LONGVARCHAR</p><p>LONGNVARCHAR (Java SE 6.0)</p></td><td><p>String </p></td></tr><tr><td><p>numeric</p></td><td><p>NUMERIC</p></td><td><p>java.math.BigDecimal</p></td></tr><tr><td><p>nvarchar</p></td><td><p>VARCHAR</p><p>NVARCHAR (Java SE 6.0)</p></td><td><p>String </p></td></tr><tr><td><p>nvarchar(max)</p></td><td><p>VARCHAR</p><p>NVARCHAR (Java SE 6.0)</p></td><td><p>String </p></td></tr><tr><td><p>real</p></td><td><p>REAL</p></td><td><p>float</p></td></tr><tr><td><p>smalldatetime</p></td><td><p>TIMESTAMP</p></td><td><p>java.sql.Timestamp</p></td></tr><tr><td><p>smallint</p></td><td><p>SMALLINT</p></td><td><p>short</p></td></tr><tr><td><p>smallmoney</p></td><td><p>DECIMAL</p></td><td><p>java.math.BigDecimal</p></td></tr><tr><td><p>text</p></td><td><p>LONGVARCHAR</p></td><td><p>String </p></td></tr><tr><td><p>time</p></td><td><p>TIME (1)</p></td><td><p>java.sql.Time (1)</p></td></tr><tr><td><p>timestamp</p></td><td><p>BINARY</p></td><td><p>byte[]</p></td></tr><tr><td><p>tinyint</p></td><td><p>TINYINT</p></td><td><p>short</p></td></tr><tr><td><p>udt</p></td><td><p>VARBINARY</p></td><td><p>byte[]</p></td></tr><tr><td><p>uniqueidentifier</p></td><td><p>CHAR</p></td><td><p>String </p></td></tr><tr><td><p>varbinary</p></td><td><p>VARBINARY</p></td><td><p>byte[]</p></td></tr><tr><td><p>varbinary(max)</p></td><td><p>VARBINARY</p></td><td><p>byte[]</p></td></tr><tr><td><p /></td><td><p /></td><td><p /></td></tr><tr><td><p>varchar</p></td><td><p>VARCHAR</p></td><td><p>String </p></td></tr><tr><td><p>varchar(max)</p></td><td><p>VARCHAR</p></td><td><p>String </p></td></tr><tr><td><p>xml</p></td><td><p>LONGVARCHAR</p><p>LONGNVARCHAR (Java SE 6.0)</p></td><td><p>String </p><p>SQLXML</p></td></tr></table></div><p>(1) pour utiliser java.sql.Time avec le type d'heure SQL Server, vous devez affecter à la propriété de connexion <span sdata="langKeyword" value="sendTimeAsDatetime"><span class="keyword">sendTimeAsDatetime</span></span> la valeur False.</p><p>(2) Vous pouvez accéder par programmation aux valeurs de <span sdata="langKeyword" value="datetimeoffset"><span class="keyword">datetimeoffset</span></span> avec<span sdata="link"><a href="20bbeacd-ccca-4a46-8184-ff941ae2ec5f.htm">Classe DateTimeOffset</a></span>.</p><p>Actuellement, le pilote JDBC ne prend pas en charge le type de données SQL Server sqlvariant. Si une requête est utilisée pour extraire des données d'une table contenant une colonne du type de données sqlvariant, une exception se produit.</p><p>Les sections suivantes proposent des exemples d'utilisation du pilote JDBC et des types de données de base. Pour des exemples plus détaillés sur l'utilisation des types de données de base dans une application Java, consultez <span sdata="link"><a href="59ac80cf-fc66-4493-933d-38e479c5f54d.htm">Exemple de types de données de base</a></span>.</p></div><h1 class="heading">Extraction de données en tant que chaîne</h1><div id="sectionSection1" class="section" name="collapseableSection" style=""><p>Si vous devez extraire des données d'une source de données qui correspond à l'un des types de données de base de JDBC pour les afficher en tant que chaîne, ou si le type des données n'est pas absolument requis, vous pouvez appliquer la méthode <a href="f81dde01-d328-4b32-8871-1efac645b68e.htm">getString</a> de la classe <a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a>, comme suit :</p><div name="snippetGroup"><div class="sampleCode"><span codeLanguage="Java"><pre>String SQL = "SELECT TOP 10 * FROM Person.Contact";
Statement stmt = con.createStatement();
ResultSet rs = stmt.executeQuery(SQL);

while (rs.next()) {
   System.out.println(rs.getString(4) + " " + rs.getString(6));
}
rs.close();
stmt.close();

</pre></span></div></div></div><h1 class="heading">Extraction de données par type de données</h1><div id="sectionSection2" class="section" name="collapseableSection" style=""><p>Si vous devez extraire des données d'une source de données et que vous connaissez le type de données extraites, utilisez l'une des méthodes <b>get&lt;Type&gt;</b> de la classe <b>SQLServerResultSet</b>, également connues comme <span class="term">méthodes d'accesseur Get</span>. Vous pouvez utiliser soit un nom de colonne, soit un index de colonne avec les méthodes <b>get&lt;Type&gt;</b>, comme suit :</p><div name="snippetGroup"><div class="sampleCode"><span codeLanguage="Java"><pre>ResultSet rs = stmt.executeQuery("SELECT lname, job_id FROM employee
   WHERE (lname = 'Brown')");
rs.next();
short empJobID = rs.getShort("job_id");
rs.close();
stmt.close();

</pre></span></div></div><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Le pilote JDBC déconseille et ne prend pas en charge les méthodes <b>getUnicodeStream</b> et <b>getBigDecimal</b> avec échelle.</p></div></div><h1 class="heading">Mise à jour des données par type de données</h1><div id="sectionSection3" class="section" name="collapseableSection" style=""><p>Si vous devez mettre à jour la valeur d'un champ dans une source de données, utilisez l'une des méthodes <b>update&lt;Type&gt;</b> de la classe <b>SQLServerResultSet</b>. Dans l'exemple suivant, la méthode <a href="2bb0319e-12cb-4604-a7e3-b22a24b02296.htm">updateInt</a> est appliquée conjointement avec la méthode <a href="cfced0ca-a281-40dc-8d2f-370d5f0bf12b.htm">updateRow</a> pour mettre à jour les données dans la source de données :</p><div name="snippetGroup"><div class="sampleCode"><span codeLanguage="Java"><pre>Statement stmt = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE); 
ResultSet rs = stmt.executeQuery("SELECT lname, job_id FROM employee
   WHERE (lname = 'Brown')");
rs.next();
short empJobID = rs.getInt(2);
empJobID++;
rs.first();
rs.updateInt(2, empJobID);
rs.updateRow();
rs.close();
stmt.close();

</pre></span></div></div><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Le pilote JDBC ne peut pas mettre à jour une colonne SQL Server avec un nom de colonne dont la longueur dépasse 127 caractères. Si une mise à jour est tentée sur une colonne dont le nom dépasse 127 caractères, une exception est levée.</p></div></div><h1 class="heading">Mise à jour des données par requête paramétrable</h1><div id="sectionSection4" class="section" name="collapseableSection" style=""><p>Si vous devez mettre à jour des données dans une source de données en utilisant une requête paramétrable, vous pouvez définir le type de données des paramètres à l'aide de l'une des méthodes <b>set&lt;Type&gt;</b> de la classe <a href="a8481c06-fbba-432b-8c69-4f4619c20ad4.htm">SQLServerPreparedStatement</a>, également connues comme <span class="term">méthodes d'accesseur Set</span>. Dans l'exemple suivant, la méthode <a href="bd4e4085-f704-4a73-b6a7-7d443d564728.htm">prepareStatement</a> est utilisée pour précompiler la requête paramétrable, puis la méthode <a href="25dabdc9-c60f-485a-87eb-306067964765.htm">setString</a> est utilisée pour définir la valeur de chaîne du paramètre avant d'appeler la méthode <a href="ca534c6b-ef4d-4ae8-8cc3-514728623cff.htm">executeUpdate</a>.</p><div name="snippetGroup"><div class="sampleCode"><span codeLanguage="Java"><pre>PreparedStatement pstmt = con.prepareStatement("UPDATE employee SET
   fname = ? WHERE (lname = 'Brown')");
String first = "Bob";
pstmt.setString(1, first);
int rowCount = pstmt.executeUpdate();
pstmt.close();

</pre></span></div></div><p>Pour plus d'informations sur les requêtes paramétrables, consultez <span sdata="link"><a href="3202b88f-ce13-44dd-982c-c6a3b0260378.htm">Utilisation d'une instruction SQL avec paramètres</a></span>.</p></div><h1 class="heading">Transmission de paramètres à une procédure stockée</h1><div id="sectionSection5" class="section" name="collapseableSection" style=""><p>Si vous devez transmettre des paramètres typés dans une procédure stockée, vous pouvez définir les paramètres par index ou par nom à l'aide de l'une des méthodes <b>set&lt;Type&gt;</b> de la classe <a href="30710a63-c05d-47d9-9cf9-c087a1c76373.htm">SQLServerCallableStatement</a>. Dans l'exemple suivant, la méthode <a href="265b024c-898a-4bd0-98b5-f06076717b9e.htm">prepareCall</a> est utilisée pour configurer l'appel de la procédure stockée, puis la méthode <a href="f38b97b5-d4f0-4f74-a33d-740241a85842.htm">setString</a> est utilisée pour définir le paramètre de l'appel avant l'appel de la méthode <a href="599cf463-e19f-4baa-bacb-513cad7c6cd8.htm">executeQuery</a>. </p><div name="snippetGroup"><div class="sampleCode"><span codeLanguage="Java"><pre>CallableStatement cstmt = con.prepareCall("{call employee_jobid(?)}");
String lname = "Brown";
cstmt.setString(1, lname);
Resultset rs = cstmt.executeQuery();
rs.close();
cstmt.close();

</pre></span></div></div><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Dans cet exemple, un jeu de résultats est retourné avec les résultats de l'exécution de la procédure stockée. </p></div><p>Pour plus d'informations sur l'utilisation du pilote JDBC avec les procédures stockées et les paramètres d'entrée, consultez <span sdata="link"><a href="8f491b70-7d1b-42bd-964f-9a8b86af5eaa.htm">Utilisation d'une procédure stockée avec des paramètres d'entrée</a></span>.</p></div><h1 class="heading">Extraction de paramètres d'une procédure stockée</h1><div id="sectionSection6" class="section" name="collapseableSection" style=""><p>Si vous devez extraire des paramètres d'une procédure stockée, vous devez tout d'abord enregistrer un paramètre OUT par nom ou index à l'aide de la méthode <a href="82f8d608-efc1-4af8-a985-ec25d19420aa.htm">registerOutParameter</a> de la classe <b>SQLServerCallableStatement</b>, puis attribuer le paramètre OUT retourné à une variable appropriée après l'exécution de l'appel de la procédure stockée. Dans l'exemple suivant, la méthode <b>prepareCall</b> est utilisée pour configurer l'appel de la procédure stockée, la méthode <b>registerOutParameter</b> est utilisée pour configurer le paramètre OUT, puis la méthode <a href="f38b97b5-d4f0-4f74-a33d-740241a85842.htm">setString</a> est utilisée pour définir le paramètre pour l'appel avant l'appel de la méthode <b>executeQuery</b>. La valeur retournée par le paramètre OUT de la procédure stockée est extraite à l'aide de la méthode <a href="9e3c51bc-7285-4f28-92c8-cfa05e49da9e.htm">getShort</a>.</p><div name="snippetGroup"><div class="sampleCode"><span codeLanguage="Java"><pre>CallableStatement cstmt = con.prepareCall("{call employee_jobid (?, ?)}");
cstmt.registerOutParameter(2, java.sql.Types.SMALLINT);
String lname = "Brown";
cstmt.setString(1, lname);
Resultset rs = cstmt.executeQuery();
short empJobID = cstmt.getShort(2);
rs.close();
cstmt.close();

</pre></span></div></div><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Outre le paramètre OUT retourné, un jeu de résultats peut également être retourné avec les résultats de l'exécution de la procédure stockée.</p></div><p>Pour plus d'informations sur l'utilisation du pilote JDBC avec les procédures stockées et les paramètres de sortie, consultez <span sdata="link"><a href="1c006f27-7e99-43d5-974c-7b782659290c.htm">Utilisation d'une procédure stockée avec des paramètres de sortie</a></span>.</p></div><span id="seeAlsoSpan"><h1 class="heading">Voir aussi</h1></span><div id="seeAlsoSection" class="section" name="collapseableSection" style=""><div class="seeAlsoStyle"><span sdata="link"><a href="7802328d-4d23-4775-9573-4169b127d258.htm">Présentation des types de données de pilote JDBC</a></span></div></div></div><div id="footer" class="section"><span id="feedbackarea">Envoyez vos <a href="javascript:SubmitFeedback('DevDocs@Microsoft.com','','','','8.0.12060.10000','%0\dMerci pour vos commentaires qui permettent aux équipes chargées de rédiger la documentation développeur d\'en améliorer la qualité. Pendant la révision de vos commentaires, il est possible que nous vous contactions par courrier électronique afin de vous demander des éclaircissements ou d\'autres commentaires sur la solution envisagée. Nous n\'utilisons pas votre adresse de messagerie dans un autre but et nous la supprimons une fois notre révision terminée.%0\APour plus d\'informations sur les politiques de confidentialité de Microsoft, consultez http://privacy.microsoft.com/fr-fr/default.aspx.%0\A%0\d','Commentaires client.');">commentaires</a> sur cette rubrique à Microsoft.</span><span id="copyrightarea"><p><a href="9bad553b-9e70-4696-8499-2e35f772a1e0.htm">© 2012 Microsoft. Tous droits réservés.</a></p></span></div></div></body></html>